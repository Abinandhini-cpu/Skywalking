# The overview topology of the whole application cluster,
# which includes all applications and dependencies, e.g. MQ, Database, Cache, outside Web Service
type ApplicationTopology {
  nodes: [Node]!
  calls: [Call]
}

# The base Node of all node types in topology
interface Node {
  # The global id of each node,
  # 1. `Application ID` represents application under monitoring
  # 2. `Peer ID` string represents the conjectural dependency.
  id: ID!
  # Application Code or literal Peer
  name: String!
  # The type name
  # 1. The most important component in the application, from service provider perspective.
  # 2. Conjectural dependent component, e.g. MySQL, Redis, Kafka
  type: String
}

# ApplicationNode represents this node is under monitoring by agent.
type ApplicationNode implements Node {
  id: ID!
  name: String!
  type: String
  # Success rate of all incoming requests.
  # Max value is 100.
  # 2 Digits after floating point.
  sla: Float!
  # The number of incoming calls
  calls: Long!
  # ref: http://www.apdex.org/
  # Max value is 1
  # 2 Digits after floating point.
  apdex: Float!
  # The number of servers in the application code
  numOfServer: Int!
  # The number of servers alerting
  numOfServerAlarm: Int!
  # The number of services alerting
  numOfServiceAlarm: Int!
}

# The conjectural node generated by exit span
type ConjecturalNode implements Node {
  id: ID!
  name: String!
  type: String
}

# The Call represents a directed distributed call,
# from the `source` to the `target`.
type Call {
  source: ID!
  target: ID!
  isAlert: Boolean
  # The protocol and tech stack used in this distributed call
  callType: String!
  callsPerSec: Int!
  # Unit: millisecond
  responseTimePerSec: Int!
}

# Query the cluster brief based on the given duration
type ClusterBrief {
  numOfApplication: Int
  numOfService: Int
  numOfDatabase: Int
  numOfCache: Int
  numOfMQ: Int
}

# Query the trend of alarm rate based on the given duration
type AlarmTrend {
  numOfAlarmRate: [Int]!
}

# Query all conjectural applications based on the given duration
# All applications here are not installed agent.
type ConjecturalAppBrief {
  apps: [ConjecturalApp!]
}

# The basic info of the conjectural application,
# includes the type and num of same type application
type ConjecturalApp {
  # The display name of the application
  # e.g. MySQL, RocketMQ, Kafka, Nginx
  name: String!
  num: Int!
}

type ApplicationBrief {
  apps: [ApplicationInfo!]
}

type ApplicationInfo {
  name: String!
  tps: Int!
}

extend type Query {
  getApplicationTopology(duration: Duration!): ApplicationTopology
  getClusterBrief(duration: Duration!): ClusterBrief
  getAlarmTrend(duration: Duration!): AlarmTrend
  getConjecturalApps(duration: Duration!): ConjecturalAppBrief
  getApplicationBrief(duration: Duration!, topN: Int!): ApplicationBrief
}
