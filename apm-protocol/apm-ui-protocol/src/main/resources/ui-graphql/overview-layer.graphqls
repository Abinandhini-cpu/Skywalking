# The overview topology of the whole application cluster,
# which includes all applications and dependencies, e.g. MQ, Database, Cache, outside Web Service
type ApplicationTopology {
  nodes: [Node]!
  calls: [Call]
  duration: Duration!
}

# The base Node of all node types in topology
interface Node {
  # The global id of each node,
  # 1. `Application ID` represents application under monitoring
  # 2. `Peer ID` string represents the conjectural dependency.
  id: ID!
  # Application Code or literal Peer
  name: String!
  # The type name
  # 1. The most important component in the application, from service provider perspective.
  # 2. Conjectural dependent component, e.g. MySQL, Redis, Kafka
  type: String
}

# ApplicationNode represents this node is under monitoring by agent.
type ApplicationNode implements Node {
  id: ID!
  name: String!
  type: String
  # Success rate of all incoming requests.
  # Max value is 100.
  # 2 Digits after floating point.
  sla: Float!
  # The number of incoming calls
  calls: Long!
  # ref: http://www.apdex.org/
  # Max value is 1
  # 2 Digits after floating point.
  apdex: Float!
  # The number of servers in the application code
  numOfServer: Int!
  # The number of servers alerting
  numOfServerAlarm: Int!
  # The number of services alerting
  numOfServiceAlarm: Int!
}

# The conjectural node generated by exit span
type ConjecturalNode implements Node {
  id: ID!
  name: String!
  type: String
}

# The Call represents a directed distributed call,
# from the `source` to the `target`.
type Call {
  source: ID!
  target: ID!
  isAlert: Boolean
  # The protocol and tech stack used in this distributed call
  callType: String!
  callsPerSec: Int!
  # Unit: millisecond
  responseTimePerSec: Int!
}

extend type Query {
  getApplicationTopology: ApplicationTopology
}
