# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# The list of traces
type TraceBrief {
  traces: [BasicTrace!]!
  total: Int!
}

# Trace basic info
type BasicTrace {
   segmentId: String!
   operationName: String!
   duration: Int!
   start: String!
   isError: Boolean
   traceIds: [String!]!
}

# Represent the conditions used for query TraceBrief
input TraceQueryCondition {
  # The value of 0 means all application.
  applicationId: Int
  traceId: String
  operationName: String
  # The time range of traces started
  queryDuration: Duration
  # The mix time of trace
  minTraceDuration: Int
  # The max time of trace
  maxTraceDuration: Int
  paging: Pagination!
}

enum QueryOrder {
  BY_START_TIME
  BY_DURATION
}

# The trace represents a distributed trace, includes all segments and spans.
type Trace {
  segments: [Segment!]!
  # Segment IDs in refs may not exist in #segments list, because MQ batch process trace segments didn't share the same ID.
  # UI should add visual node for non-exist segment.
  refs: [SegmentRef!]!
}

type Segment {
  segmentId: ID!
  applicationCode: ID!
  # The segment name, which should be named by Entry span operation name, or the first span operation name when no Entry span
  name: String!
  # Brief includes all outside service info, also could be understood as a brief of all Exit spans.
  brief: SegmentBrief!
  spans: [Span!]!
  # True if exist an error in the all spans
  isError: Boolean
  # The real duration of this segment, exclude all outside services' duration.
  # Unit: milliseconds
  duration: Long!
}

type SegmentBrief {
  http: BriefInfo!
  rpc: BriefInfo!
  mq: BriefInfo!
  db: BriefInfo!
  cache: BriefInfo!
}

# Brief info includes metrics of the certain layer type
type BriefInfo {
  # The number of this layer calls
  count: Int!
  # The duration of all calls in this layer.
  duration: Long!
}

type SegmentRef {
  sourceSegment: ID!
  targetSegment: ID!
  # Layer type of this across process segment call.
  # Or `Cross Thread`.
  callType: String!
}


type Span {
  spanId: Int!
  parentSpanId: Int!
  refs: [Ref!]!
  startTime: Long!
  endTime: Long!
  operationName: String
  # There are three span types: Local, Entry and Exit
  type: String!
  # Peer network id, e.g. host+port, ip+port
  peer: String
  component: String
  isError: Boolean
  # There are 5 layers: Unknown, Database, RPCFramework, Http, MQ and Cache
  layer: String
  tags: [KeyValue!]!
  logs: [LogEntity!]!
}

# Ref represents the link between the segment and its parents.
# The parent(ref) may not exists, which means batch process.
# The UI should display a list, representing the other trace IDs.
type Ref {
  traceId: ID!
  parentSegmentId: ID!
  parentSpanId: Int!
  # Ref type represents why did the ref happen.
  # Include: 1) CrossProcess 2) CrossThread
  type: RefType!
}

enum RefType {
  CROSS_PROCESS,
  CROSS_THREAD
}

type KeyValue {
  key: String!
  value: String
}

type LogEntity {
  time: Long!
  data: [KeyValue!]
}

extend type Query {
   queryBasicTraces(condition: TraceQueryCondition): TraceBrief
   queryTrace(traceId: ID!): Trace
}
