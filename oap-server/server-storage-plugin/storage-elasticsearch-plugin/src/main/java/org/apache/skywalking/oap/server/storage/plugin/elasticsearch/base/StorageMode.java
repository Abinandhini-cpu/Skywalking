/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.skywalking.oap.server.storage.plugin.elasticsearch.base;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import org.apache.skywalking.apm.util.StringUtil;
import org.apache.skywalking.oap.server.core.Const;
import org.apache.skywalking.oap.server.core.storage.model.Model;

@Slf4j
public enum StorageMode {
    /**
     * FUNCTIONAL_AGGREGATION means the telemetry data, that generated by OAL or MAL, would be partitioned by the
     * functions of the OAL or MAL.
     */
    FUNCTIONAL_AGGREGATION(
        model -> StringUtil.isNotBlank(model.getAggregationFunctionName())
            ? model.getAggregationFunctionName() : model.getName(),
        Model::getName
    ),
    /**
     * NO_AGGREGATION means no aggregation operation in storage.
     */
    NO_AGGREGATION(Model::getName, item -> Const.EMPTY_STRING);

    private final TableSelector selector;
    private final IdPrefixMaker maker;
    private static final Base64.Encoder ENCODER = Base64.getEncoder();
    public static final String LOGIC_TABLE_NAME = "logic_table";

    StorageMode(TableSelector selector,
                final IdPrefixMaker maker) {
        this.selector = selector;
        this.maker = maker;
    }

    public String getTableName(Model model) {
        return this.selector.select(model);
    }

    /**
     * Generate the unique id.
     */
    public String generateDocId(Model model, String originalID) {
        return StorageMode.forceWarpId(this.maker.make(model), originalID);
    }

    /**
     * Check the mode of the Model definition.
     */
    public boolean isAggregationMode(Model model) {
        switch (this) {
            case FUNCTIONAL_AGGREGATION:
                return StringUtil.isNotBlank(model.getAggregationFunctionName());
            case NO_AGGREGATION:
            default:
                return false;
        }
    }

    /**
     * Append the value to the {@link #LOGIC_TABLE_NAME} when running in the aggregation mode.
     */
    public Map<String, Object> appendAggregationColumn(Model model, Map<String, Object> columns) {
        if (!isAggregationMode(model)) {
            return columns;
        }
        columns.put(LOGIC_TABLE_NAME, ENCODER.encodeToString(model.getName().getBytes(StandardCharsets.UTF_8)));
        return columns;
    }

    /**
     * When using the aggregation mode, the logicTableName is a part of new storage id to avoid conflicts.
     */
    public static String forceWarpId(String logicTableName, String originalID) {
        return ENCODER.encodeToString(logicTableName.getBytes(StandardCharsets.UTF_8)) + originalID;
    }

    /**
     * When using the aggregation mode, a column named {@link #LOGIC_TABLE_NAME} would be append to the physical table.
     * The value of the column is the original table name in {@link #NO_AGGREGATION} mode, such as the OAL name. And,
     * the value is encoded by BASE64.
     */
    public static String getLogicTableName(String logicTableName) {
        return ENCODER.encodeToString(logicTableName.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Find storage mode by name.
     */
    public static StorageMode findByName(String name) {
        for (final StorageMode mode : StorageMode.values()) {
            if (mode.name().equalsIgnoreCase(name)) {
                return mode;
            }
        }
        log.warn("cannot find {} mode, NO_AGGREGATION would be used as the storage mode.", name);
        return NO_AGGREGATION;
    }

    @FunctionalInterface
    public interface TableSelector {
        String select(Model model);
    }

    @FunctionalInterface
    public interface IdPrefixMaker {
        String make(Model model);
    }
}
